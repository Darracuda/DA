// Динамическое программирование
// 5. Обход матрицы
//Задана матрица натуральных чисел A размерности n × m.Из текущей клетки можно перейти в любую из 3 - х
//соседних, стоящих в строке с номером на единицу больше, при этом за каждый проход через клетку(i, j)
//взымается штраф Ai, j.Необходимо пройти из какой - нибудь клетки верхней строки до любой клетки нижней,
//набрав при проходе по клеткам минимальный штраф.
//Входные данные
//Первая строка входного файла содержит в себе пару чисел 2 ≤ n ≤ 1000 и 2 ≤ m ≤ 1000, затем следует n строк
//из m целых чисел.
//
//Выходные данные
//Необходимо вывести в выходной файл на первой строке минимальный штраф, а на второй —
//последовательность координат из n ячеек, через которые пролегает маршрут с минимальным штрафом.
//Пример
//3 3 3 1 2 7 4 5 8 6 3 8 (1, 2) (2, 2) (3, 3)

#include <iostream>
#include <vector>

using namespace std;

const int maxRowCount = 1000;								// максимальные размеры матрицы (по условию задачи)
const int maxColumnCount = 1000;
int rowCount, columnCount;									// текущий размер матрицы
long long int matrix[maxRowCount][maxColumnCount];			// двумерный массив - матрица A

//--- MINIM --------------------------------------------------
// впосмогательный  алгоритм : найти в строке row матрицы А среди length элементов, начиная с column, индекс элемента с мЕньшим штрафом
// 
// row - номер строки
// col - номер колонки (осторожно! номер колонки может выйти за пределы матрицы)
// len - количество колонок (осторожно! номер колонки + количество может вый за пределы матрицы)
int minim(int row, int column, int length)
{
	int columnOfMin = max(column, 0);							// насчнем с индекса первого элемента 
	for (int i = columnOfMin + 1; i < min(column + length, columnCount); i++)		// крутим цикл для последующих элементов
	{
		if (matrix[row][i] < matrix[row][columnOfMin])			// если есть элемент с меньшим шттрафом
			columnOfMin = i;									// то запоминаем его индекс
	}
	return columnOfMin;
}

//--- MAIN --------------------------------------------------
// основной алгоритм

int main()
{

	cin >> rowCount;                       // вводим размерности матрицы N * M (N-количество строк, M-количество столбцов)
	cin >> columnCount;                       // где 2 <= N <= 1000 и 2 <= M <= 1000

	//---- в цикле заполняем иатрицу А
	for (int row = 0; row < rowCount; row++)
		for (int column = 0; column < columnCount; column++)
			cin >> matrix[row][column];         // вводим очередной элемент

	//---- делаем расчет вспомогательной матрицы индексов и матрицы штрафов
	for (int row = rowCount - 1 - 1; row >= 0; row--)		// начнем с последнего уровня и двинем обратно к начальному уровню
		for (int column = 0; column < columnCount; column++)
		{
			int index = minim(row + 1, column - 1, 3);		// найти индекс одного из 3х соседних элементов уровнем ниже, элемент с минимальным штрафом
			matrix[row][column] += matrix[row + 1][index];		// заполняем матрицу штрафов исходя из индекса и штрафов с последующей строки матрицы штрафов
		}
	//---- находим колонку в первой строке, где находится элемент с минимальным штрафом
	int startColumn = minim(0, 0, columnCount);         // найти индекс одного из всех элементов первой строки матрицы, элемент с минимальным штрафом
	cout << matrix[0][startColumn] << endl;				// вывести сам штраф

	//--- обход матрицы и вывод пути обхода
	int column = startColumn;							// начнем с колонки с минимальным штрафом в первой строке матрицы
	for (int row = 0; row < rowCount; row++)			// начнем с первой строки матрицы и будем идти к следующим
	{
		cout << "(" << (row + 1) << "," << (column + 1) << ") ";	// выводим координаты элемента с минимальным штрафом в текущем строке
		if (row < rowCount -1)										// и для всех встрок, кроме последней
			column = minim (row + 1, column-1, 3);					// ищем колонку элемента с минимальным штрафом в следующей строке
	}
	cout << endl;
}
